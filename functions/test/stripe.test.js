/**
 * Stripe Integration Tests
 *
 * Verifies that Stripe is properly configured and all billing functions
 * work as expected BEFORE implementing client-side changes.
 *
 * These tests use the REAL Stripe Test Mode API — no emulators needed.
 *
 * Config loading priority:
 *   1. Firestore admin/stripe (requires: gcloud auth application-default login)
 *   2. Local file: test/.stripe-test-config.json  (auto-generated by fetch script)
 *
 * Quick start:
 *   cd functions
 *   node test/fetch-stripe-config.js          # one-time: saves config locally
 *   npm run test:stripe                       # run the tests
 *
 * For webhook mock tests (section 7), also set:
 *   FUNCTIONS_URL=https://stripewebhookmock-ylrliabaza-uc.a.run.app npm run test:stripe
 */

const { expect } = require('chai');
const Stripe = require('stripe');
const path = require('path');
const fs = require('fs');

const PROJECT_ID = 'snapsign-au';
const LOCAL_CONFIG_PATH = path.join(__dirname, '.stripe-test-config.json');

let adminApp = null; // firebase-admin app, if available
let db = null;
let rawDoc;      // The raw Firestore document (with mode, test, prod sub-objects)
let stripeCfg;   // Resolved config for the active mode (flat: apiKey, priceIds, etc.)
let stripe;

/**
 * Resolve mode-specific config from the raw Firestore doc.
 * Mirrors getStripeAdminConfig() from index.js.
 */
function resolveConfig(doc) {
  const mode = String(doc.mode || 'test');
  const modeConfig = doc[mode] || {};
  return {
    successUrl: doc.successUrl || null,
    cancelUrl: doc.cancelUrl || null,
    portalReturnUrl: doc.portalReturnUrl || null,
    ...modeConfig,
    _mode: mode,
  };
}

/**
 * Try loading Stripe config: Firestore first, then local file fallback.
 */
async function loadRawConfig() {
  // --- Attempt 1: Firestore via firebase-admin ---
  try {
    const admin = require('firebase-admin');
    if (!admin.apps.length) {
      admin.initializeApp({ projectId: PROJECT_ID });
    }
    adminApp = admin.app();
    db = admin.firestore();

    const snap = await db.collection('admin').doc('stripe').get();
    if (snap.exists) {
      console.log('  ✓ Config loaded from Firestore (admin/stripe)\n');
      return snap.data();
    }
  } catch (e) {
    console.warn(`  ⚠ Firestore unavailable (${e.message?.slice(0, 80)})`);
    console.warn('    Falling back to local config file...\n');
    if (adminApp) {
      try { await adminApp.delete(); } catch (_) {}
      adminApp = null;
      db = null;
    }
  }

  // --- Attempt 2: Local config file ---
  if (fs.existsSync(LOCAL_CONFIG_PATH)) {
    const raw = fs.readFileSync(LOCAL_CONFIG_PATH, 'utf8');
    const cfg = JSON.parse(raw);
    console.log('  ✓ Config loaded from test/.stripe-test-config.json\n');
    return cfg;
  }

  throw new Error(
    'Could not load Stripe config.\n' +
    '  Option A: gcloud auth application-default login\n' +
    '  Option B: node test/fetch-stripe-config.js  (creates local config file)'
  );
}

// ─── Setup & Teardown ────────────────────────────────────────────────────────

describe('Stripe Integration Tests', function () {
  this.timeout(30000);

  before(async () => {
    rawDoc = await loadRawConfig();
    stripeCfg = resolveConfig(rawDoc);

    console.log(`  Mode: ${stripeCfg._mode}\n`);

    // Initialize Stripe SDK with the active mode's key
    stripe = new Stripe(stripeCfg.apiKey);
  });

  after(async () => {
    if (adminApp) {
      try { await adminApp.delete(); } catch (_) {}
    }
  });

  // ─── 1. Config Structure Validation ──────────────────────────────────────

  describe('1 · Config Structure (admin/stripe)', () => {
    it('should have mode field set to "test" or "prod"', () => {
      expect(rawDoc.mode).to.be.oneOf(['test', 'prod']);
    });

    it('should have shared successUrl pointing to /profile', () => {
      expect(rawDoc.successUrl).to.be.a('string');
      expect(rawDoc.successUrl).to.include('/profile');
      expect(rawDoc.successUrl).to.include('stripe=success');
    });

    it('should have shared cancelUrl pointing to /pricing', () => {
      expect(rawDoc.cancelUrl).to.be.a('string');
      expect(rawDoc.cancelUrl).to.include('/pricing');
      expect(rawDoc.cancelUrl).to.include('stripe=cancel');
    });

    it('should have shared portalReturnUrl', () => {
      expect(rawDoc.portalReturnUrl).to.be.a('string');
      expect(rawDoc.portalReturnUrl).to.include('/profile');
    });

    it('should have test sub-object with required keys', () => {
      const t = rawDoc.test;
      expect(t).to.be.an('object');
      expect(t.apiKey).to.match(/^sk_test_/);
      expect(t.publishableKey).to.match(/^pk_test_/);
      expect(t.productIds?.pro).to.match(/^prod_/);
      expect(t.priceIds?.pro_monthly).to.match(/^price_/);
      expect(t.priceIds?.pro_annual).to.match(/^price_/);
      expect(t.priceIds?.pro_monthly_aud).to.match(/^price_/);
      expect(t.priceIds?.pro_annual_aud).to.match(/^price_/);
    });

    it('should have prod sub-object with required keys', () => {
      const p = rawDoc.prod;
      expect(p).to.be.an('object');
      expect(p.apiKey).to.match(/^sk_live_/);
      expect(p.publishableKey).to.match(/^pk_live_/);
      expect(p.productIds?.pro).to.match(/^prod_/);
      expect(p.priceIds?.pro_monthly).to.match(/^price_/);
      expect(p.priceIds?.pro_annual).to.match(/^price_/);
      expect(p.priceIds?.pro_monthly_aud).to.match(/^price_/);
      expect(p.priceIds?.pro_annual_aud).to.match(/^price_/);
    });

    it('should not have stale top-level apiKey or priceIds', () => {
      expect(rawDoc).to.not.have.property('apiKey');
      expect(rawDoc).to.not.have.property('publishableKey');
      expect(rawDoc).to.not.have.property('priceIds');
      expect(rawDoc).to.not.have.property('productIds');
    });

    it('resolved config should have test-mode keys (mode=test)', () => {
      expect(stripeCfg._mode).to.equal('test');
      expect(stripeCfg.apiKey).to.match(/^sk_test_/);
      expect(stripeCfg.publishableKey).to.match(/^pk_test_/);
    });

    it('should warn if webhookSecret (whsec_) is missing', () => {
      const secret = stripeCfg.webhookSecret || '';
      if (!secret.startsWith('whsec_')) {
        console.warn(
          '  ⚠  webhookSecret (whsec_...) is missing — real webhooks will fail.\n' +
          '     Set up a webhook endpoint in Stripe Dashboard → Developers → Webhooks\n' +
          '     pointing to your deployed stripeWebhook Cloud Function URL.'
        );
      }
    });
  });

  // ─── 2. Stripe API Connectivity ──────────────────────────────────────────

  describe('2 · Stripe API Connectivity', () => {
    it('should authenticate with the test API key', async () => {
      const account = await stripe.accounts.retrieve();
      expect(account).to.have.property('id');
      expect(account.id).to.be.a('string');
      console.log(`    → Account: ${account.id} (${account.business_profile?.name || 'unnamed'})`);
    });

    it('should be in test mode (livemode === false)', async () => {
      const bal = await stripe.balance.retrieve();
      expect(bal.livemode).to.equal(false, 'API key must be a TEST mode key');
    });
  });

  // ─── 3. Product & Price Verification (USD + AUD) ─────────────────────────

  describe('3 · Product & Prices', () => {
    let product;
    let monthlyUsd, annualUsd, monthlyAud, annualAud;

    before(async () => {
      const ids = stripeCfg.priceIds;
      [product, monthlyUsd, annualUsd, monthlyAud, annualAud] = await Promise.all([
        stripe.products.retrieve(stripeCfg.productIds.pro),
        stripe.prices.retrieve(ids.pro_monthly),
        stripe.prices.retrieve(ids.pro_annual),
        stripe.prices.retrieve(ids.pro_monthly_aud),
        stripe.prices.retrieve(ids.pro_annual_aud),
      ]);
    });

    it('should have an active Pro product', () => {
      expect(product.active).to.equal(true, 'Product must be active');
      console.log(`    → Product: ${product.name} (${product.id})`);
    });

    // USD prices
    it('USD monthly price should be active and recurring/month', () => {
      expect(monthlyUsd.active).to.equal(true);
      expect(monthlyUsd.type).to.equal('recurring');
      expect(monthlyUsd.recurring.interval).to.equal('month');
      expect(monthlyUsd.currency).to.equal('usd');
      expect(monthlyUsd.product).to.equal(stripeCfg.productIds.pro);
      console.log(`    → USD Monthly: $${monthlyUsd.unit_amount / 100}/mo`);
    });

    it('USD annual price should be active and recurring/year', () => {
      expect(annualUsd.active).to.equal(true);
      expect(annualUsd.type).to.equal('recurring');
      expect(annualUsd.recurring.interval).to.equal('year');
      expect(annualUsd.currency).to.equal('usd');
      console.log(`    → USD Annual: $${annualUsd.unit_amount / 100}/yr`);
    });

    it('USD annual should be cheaper per-month than USD monthly', () => {
      expect(annualUsd.unit_amount / 12).to.be.lessThan(monthlyUsd.unit_amount);
    });

    // AUD prices
    it('AUD monthly price should be active and recurring/month', () => {
      expect(monthlyAud.active).to.equal(true);
      expect(monthlyAud.type).to.equal('recurring');
      expect(monthlyAud.recurring.interval).to.equal('month');
      expect(monthlyAud.currency).to.equal('aud');
      expect(monthlyAud.product).to.equal(stripeCfg.productIds.pro);
      console.log(`    → AUD Monthly: A$${monthlyAud.unit_amount / 100}/mo`);
    });

    it('AUD annual price should be active and recurring/year', () => {
      expect(annualAud.active).to.equal(true);
      expect(annualAud.type).to.equal('recurring');
      expect(annualAud.recurring.interval).to.equal('year');
      expect(annualAud.currency).to.equal('aud');
      console.log(`    → AUD Annual: A$${annualAud.unit_amount / 100}/yr`);
    });

    it('AUD annual should be cheaper per-month than AUD monthly', () => {
      expect(annualAud.unit_amount / 12).to.be.lessThan(monthlyAud.unit_amount);
    });
  });

  // ─── 4. Checkout Session Creation ────────────────────────────────────────

  describe('4 · Checkout Sessions', () => {
    it('should create a USD monthly checkout session', async () => {
      const session = await stripe.checkout.sessions.create({
        mode: 'subscription',
        line_items: [{ price: stripeCfg.priceIds.pro_monthly, quantity: 1 }],
        success_url: stripeCfg.successUrl,
        cancel_url: stripeCfg.cancelUrl,
        client_reference_id: 'test-puid-usd-monthly',
        metadata: { firebaseUid: 'test-uid', puid: 'test-puid', billing: 'monthly', currency: 'usd' },
      });

      expect(session.id).to.match(/^cs_test_/);
      expect(session.url).to.include('checkout.stripe.com');
      expect(session.mode).to.equal('subscription');
      expect(session.status).to.equal('open');
      console.log(`    → USD Session: ${session.id}`);
    });

    it('should create an AUD monthly checkout session', async () => {
      const session = await stripe.checkout.sessions.create({
        mode: 'subscription',
        line_items: [{ price: stripeCfg.priceIds.pro_monthly_aud, quantity: 1 }],
        success_url: stripeCfg.successUrl,
        cancel_url: stripeCfg.cancelUrl,
        client_reference_id: 'test-puid-aud-monthly',
        metadata: { firebaseUid: 'test-uid', puid: 'test-puid', billing: 'monthly', currency: 'aud' },
      });

      expect(session.id).to.match(/^cs_test_/);
      expect(session.url).to.include('checkout.stripe.com');
      console.log(`    → AUD Session: ${session.id}`);
    });

    it('should create an annual checkout session', async () => {
      const session = await stripe.checkout.sessions.create({
        mode: 'subscription',
        line_items: [{ price: stripeCfg.priceIds.pro_annual, quantity: 1 }],
        success_url: stripeCfg.successUrl,
        cancel_url: stripeCfg.cancelUrl,
        client_reference_id: 'test-puid-annual',
      });

      expect(session.id).to.match(/^cs_test_/);
      expect(session.url).to.include('checkout.stripe.com');
    });

    it('should embed correct success & cancel URLs', async () => {
      const session = await stripe.checkout.sessions.create({
        mode: 'subscription',
        line_items: [{ price: stripeCfg.priceIds.pro_monthly, quantity: 1 }],
        success_url: stripeCfg.successUrl,
        cancel_url: stripeCfg.cancelUrl,
        client_reference_id: 'test-puid-urls',
      });

      expect(session.success_url).to.equal(stripeCfg.successUrl);
      expect(session.cancel_url).to.equal(stripeCfg.cancelUrl);
    });
  });

  // ─── 5. Mode Switching Logic ─────────────────────────────────────────────

  describe('5 · Mode Switching', () => {
    it('resolveConfig("test") should return test keys', () => {
      const cfg = resolveConfig({ ...rawDoc, mode: 'test' });
      expect(cfg._mode).to.equal('test');
      expect(cfg.apiKey).to.match(/^sk_test_/);
      expect(cfg.publishableKey).to.match(/^pk_test_/);
      expect(cfg.successUrl).to.equal(rawDoc.successUrl);
    });

    it('resolveConfig("prod") should return live keys', () => {
      const cfg = resolveConfig({ ...rawDoc, mode: 'prod' });
      expect(cfg._mode).to.equal('prod');
      expect(cfg.apiKey).to.match(/^sk_live_/);
      expect(cfg.publishableKey).to.match(/^pk_live_/);
      expect(cfg.successUrl).to.equal(rawDoc.successUrl);
    });

    it('resolveConfig with missing mode should default to "test"', () => {
      const cfg = resolveConfig({ ...rawDoc, mode: undefined });
      expect(cfg._mode).to.equal('test');
      expect(cfg.apiKey).to.match(/^sk_test_/);
    });

    it('test and prod should use different Stripe accounts', () => {
      expect(rawDoc.test.apiKey).to.not.equal(rawDoc.prod.apiKey);
      expect(rawDoc.test.productIds.pro).to.not.equal(rawDoc.prod.productIds.pro);
    });

    it('both modes should have all 4 price IDs (USD + AUD)', () => {
      for (const mode of ['test', 'prod']) {
        const ids = rawDoc[mode].priceIds;
        expect(ids.pro_monthly, `${mode}.pro_monthly`).to.match(/^price_/);
        expect(ids.pro_annual, `${mode}.pro_annual`).to.match(/^price_/);
        expect(ids.pro_monthly_aud, `${mode}.pro_monthly_aud`).to.match(/^price_/);
        expect(ids.pro_annual_aud, `${mode}.pro_annual_aud`).to.match(/^price_/);
      }
    });
  });

  // ─── 6. Helper Logic (unit tests) ───────────────────────────────────────

  describe('6 · Helper Logic', () => {
    const isStripeProStatus = (status) => status === 'active';

    const makeGetStripeClient = () => {
      return (adminCfg) => {
        const apiKey = String(adminCfg?.apiKey || '');
        if (!apiKey.startsWith('sk_')) {
          throw new Error('Stripe apiKey is missing in Firestore admin/stripe');
        }
        return new Stripe(apiKey);
      };
    };

    describe('isStripeProStatus', () => {
      it('"active" → true', () => expect(isStripeProStatus('active')).to.be.true);
      it('"trialing" → false', () => expect(isStripeProStatus('trialing')).to.be.false);
      it('"past_due" → false', () => expect(isStripeProStatus('past_due')).to.be.false);
      it('"canceled" → false', () => expect(isStripeProStatus('canceled')).to.be.false);
      it('"unpaid" → false', () => expect(isStripeProStatus('unpaid')).to.be.false);
      it('"incomplete" → false', () => expect(isStripeProStatus('incomplete')).to.be.false);
      it('null → false', () => expect(isStripeProStatus(null)).to.be.false);
      it('undefined → false', () => expect(isStripeProStatus(undefined)).to.be.false);
    });

    describe('getStripeClient validation', () => {
      const getStripeClient = makeGetStripeClient();

      it('should throw for null config', () => {
        expect(() => getStripeClient(null)).to.throw('apiKey is missing');
      });

      it('should throw for empty config', () => {
        expect(() => getStripeClient({})).to.throw('apiKey is missing');
      });

      it('should throw for publishable key (pk_)', () => {
        expect(() => getStripeClient({ apiKey: 'pk_test_xxx' })).to.throw('apiKey is missing');
      });

      it('should throw for live key accidentally used', () => {
        expect(() => getStripeClient({ apiKey: 'sk_live_xxx' })).to.not.throw();
      });

      it('should succeed for test secret key (sk_test_)', () => {
        expect(() => getStripeClient({ apiKey: 'sk_test_xxx' })).to.not.throw();
      });
    });

    describe('currency-based price key resolution', () => {
      // Mirrors the logic in stripeCreateCheckoutSession
      function resolvePriceKey(plan, billing, currency) {
        const billingKey = billing === 'annual' ? 'annual' : 'monthly';
        const currencySuffix = currency === 'usd' ? '' : `_${currency}`;
        return `${plan}_${billingKey}${currencySuffix}`;
      }

      it('pro + monthly + usd → pro_monthly', () => {
        expect(resolvePriceKey('pro', 'monthly', 'usd')).to.equal('pro_monthly');
      });
      it('pro + annual + usd → pro_annual', () => {
        expect(resolvePriceKey('pro', 'annual', 'usd')).to.equal('pro_annual');
      });
      it('pro + monthly + aud → pro_monthly_aud', () => {
        expect(resolvePriceKey('pro', 'monthly', 'aud')).to.equal('pro_monthly_aud');
      });
      it('pro + annual + aud → pro_annual_aud', () => {
        expect(resolvePriceKey('pro', 'annual', 'aud')).to.equal('pro_annual_aud');
      });
      it('business + monthly + usd → business_monthly', () => {
        expect(resolvePriceKey('business', 'monthly', 'usd')).to.equal('business_monthly');
      });
    });
  });

  // ─── 7. Webhook Mock Endpoint ────────────────────────────────────────────

  describe('7 · Webhook Mock (stripeWebhookMock)', () => {
    const MOCK_URL = process.env.FUNCTIONS_URL
      ? `${process.env.FUNCTIONS_URL.replace(/\/$/, '')}/stripeWebhookMock`
      : null;

    const CLEANUP_UIDS = [];

    afterEach(async () => {
      if (!db) return;
      for (const uid of CLEANUP_UIDS) {
        try { await db.collection('users').doc(uid).delete(); } catch (_) {}
      }
      CLEANUP_UIDS.length = 0;
    });

    before(function () {
      if (!MOCK_URL) {
        console.warn(
          '\n  ⚠  FUNCTIONS_URL not set — skipping webhook mock tests.\n' +
          '     Run with: FUNCTIONS_URL=https://stripewebhookmock-ylrliabaza-uc.a.run.app npm run test:stripe\n'
        );
        this.skip();
      }
      if (!db) {
        console.warn(
          '\n  ⚠  Firestore not available — webhook Firestore assertions will be skipped.\n'
        );
      }
    });

    it('should reject requests without x-mock-secret header', async function () {
      if (!MOCK_URL) this.skip();
      const res = await fetch(MOCK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'customer.subscription.created',
          data: { object: { id: 'sub_test', status: 'active', customer: 'cus_test', metadata: { firebaseUid: 'x' } } },
        }),
      });
      expect(res.status).to.equal(403);
    });

    it('should reject requests with wrong x-mock-secret', async function () {
      if (!MOCK_URL) this.skip();
      const res = await fetch(MOCK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-mock-secret': 'wrong' },
        body: JSON.stringify({
          type: 'customer.subscription.created',
          data: { object: { id: 'sub_test', status: 'active', customer: 'cus_test', metadata: { firebaseUid: 'x' } } },
        }),
      });
      expect(res.status).to.equal(403);
    });

    it('should reject requests without firebaseUid in metadata', async function () {
      if (!MOCK_URL) this.skip();
      const res = await fetch(MOCK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-mock-secret': stripeCfg.mockWebhookSecret },
        body: JSON.stringify({
          type: 'customer.subscription.created',
          data: { object: { id: 'sub_test', status: 'active', customer: 'cus_test', metadata: {} } },
        }),
      });
      expect(res.status).to.equal(400);
    });

    it('should process subscription.created → isPro=true', async function () {
      if (!MOCK_URL) this.skip();
      const testUid = `stripe-test-create-${Date.now()}`;
      CLEANUP_UIDS.push(testUid);

      const res = await fetch(MOCK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-mock-secret': stripeCfg.mockWebhookSecret },
        body: JSON.stringify({
          type: 'customer.subscription.created',
          data: { object: { id: `sub_mock_${Date.now()}`, status: 'active', customer: `cus_mock_${Date.now()}`, metadata: { firebaseUid: testUid } } },
        }),
      });

      const body = await res.json();
      expect(res.status).to.equal(200);
      expect(body.ok).to.equal(true);
      expect(body.isPro).to.equal(true);

      if (db) {
        const userDoc = await db.collection('users').doc(testUid).get();
        expect(userDoc.exists).to.equal(true);
        const sub = userDoc.data()?.subscription;
        expect(sub.isPro).to.equal(true);
        expect(sub.status).to.equal('active');
        expect(sub.provider).to.equal('stripe');
      }
    });

    it('should process subscription.deleted → isPro=false', async function () {
      if (!MOCK_URL) this.skip();
      const testUid = `stripe-test-cancel-${Date.now()}`;
      CLEANUP_UIDS.push(testUid);

      // Create active subscription first
      await fetch(MOCK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-mock-secret': stripeCfg.mockWebhookSecret },
        body: JSON.stringify({
          type: 'customer.subscription.created',
          data: { object: { id: 'sub_mock_cancel', status: 'active', customer: 'cus_mock_cancel', metadata: { firebaseUid: testUid } } },
        }),
      });

      // Now cancel
      const res = await fetch(MOCK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-mock-secret': stripeCfg.mockWebhookSecret },
        body: JSON.stringify({
          type: 'customer.subscription.deleted',
          data: { object: { id: 'sub_mock_cancel', status: 'canceled', customer: 'cus_mock_cancel', metadata: { firebaseUid: testUid } } },
        }),
      });

      const body = await res.json();
      expect(res.status).to.equal(200);
      expect(body.isPro).to.equal(false);

      if (db) {
        const userDoc = await db.collection('users').doc(testUid).get();
        expect(userDoc.data()?.subscription?.isPro).to.equal(false);
        expect(userDoc.data()?.subscription?.status).to.equal('canceled');
      }
    });

    it('should process subscription.updated (past_due) → isPro=false', async function () {
      if (!MOCK_URL) this.skip();
      const testUid = `stripe-test-pastdue-${Date.now()}`;
      CLEANUP_UIDS.push(testUid);

      const res = await fetch(MOCK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'x-mock-secret': stripeCfg.mockWebhookSecret },
        body: JSON.stringify({
          type: 'customer.subscription.updated',
          data: { object: { id: 'sub_mock_pastdue', status: 'past_due', customer: 'cus_mock_pastdue', metadata: { firebaseUid: testUid } } },
        }),
      });

      const body = await res.json();
      expect(res.status).to.equal(200);
      expect(body.isPro).to.equal(false);
    });

    it('should reject non-POST methods', async function () {
      if (!MOCK_URL) this.skip();
      const res = await fetch(MOCK_URL, { method: 'GET' });
      expect(res.status).to.equal(405);
    });
  });
});
